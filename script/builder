#!/usr/bin/env ruby

ENV["RAILS_ENV"] = 'builder'

require File.expand_path(File.dirname(__FILE__) + '/../config/boot')
require 'optparse'
require 'fileutils'

CRUISE_OPTIONS = { :verbose => false }

ARGV.options do |opts|
  opts.banner = "Usage: cruise builder <project_name> [options]"

  opts.separator ""

  opts.on("-t", "--trace", "Trace-level (verbose) logging") { CRUISE_OPTIONS[:verbose] = true }
  opts.on("-h", "--help",
          "Show this help message.") { puts opts; exit }

  args = opts.parse!

  unless args.length == 1
    STDERR.puts "Project name not specified"
    STDERR.puts
    puts opts
    exit(-1)
  end

  CRUISE_OPTIONS[:project_name] = args[0]
end

require File.expand_path(File.dirname(__FILE__) + "/../config/environment")

CruiseControl::Log.verbose = CRUISE_OPTIONS[:verbose]

project_path = File.expand_path(Configuration.projects_root.join(CRUISE_OPTIONS[:project_name]))

unless File.directory? project_path
  STDERR.puts "Project '#{CRUISE_OPTIONS[:project_name]}' not found in '#{project_path}'"
  exit(-1)
end

def write_to_log_and_console(message, severity = :info)
  CruiseControl::Log.event(message, severity) rescue nil
  (puts message unless CRUISE_OPTIONS[:verbose]) rescue nil 
end

def startup(project)
  Platform.project_pid_file(project.name).tap do |f|
    f.dirname.mkpath
    f.open("w") {|f| f.write Process.pid }
  end

  ProjectBlocker.block(project)
end

def cleanup(project)
  if project
    ProjectBlocker.release(project) rescue nil
    Platform.project_pid_file(project.name).delete
  end

  write_to_log_and_console "Builder for project '#{CRUISE_OPTIONS[:project_name]}' exited"
end

def load_project(path)
  begin
    Project.read(path)
  rescue Exception => e
    write_to_log_and_console("Failed to load the new project configuration. The builder will stop.", :fatal)
    raise
  end
end

def migrate_old_logs
  old_log = File.expand_path("log/#{CRUISE_OPTIONS[:project_name]}_builder.log")
  if File.exists? old_log
    new_log = File.expand_path(CRUISE_OPTIONS[:log_file_name])
    if File.exists? new_log
      FileUtils.mv(old_log, "#{new_log}.old")
    else
      FileUtils.mv(old_log, new_log)
    end
  end
end

project = nil

begin
  migrate_old_logs
  project = load_project(project_path)
  startup(project)

  write_to_log_and_console "Builder for project '#{project.name}' started"
  puts "Logging to: #{File.expand_path(CRUISE_OPTIONS[:log_file_name])}"

  while (true) do
    catch(:reload_project) do
      project.scheduler.run
    end
    project = load_project(project_path)
    # this will cause the next call to scheduler to run the build immediately
    project.request_build rescue nil
  end
rescue Interrupt
  # this is okay, we're just control-c'ing the app
rescue Exception => e
  begin
    CruiseControl::Log.fatal(e)
  rescue => logging_error
    STDERR.puts e.message
    STDERR.puts e.backtrace.map { |line| "    #{line}" }
    STDERR.puts "Attempt to log the above error failed with this:"
    STDERR.puts logging_error.message
    STDERR.puts logging_error.backtrace
  end
  CRUISE_OPTIONS[:verbose] ? raise : exit(1)
ensure
  cleanup(project)
end

